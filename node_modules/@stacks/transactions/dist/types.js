"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializePostCondition = exports.serializePostCondition = exports.deserializeLPList = exports.serializeLPList = exports.createLPList = exports.deserializeAssetInfo = exports.serializeAssetInfo = exports.deserializeMemoString = exports.serializeMemoString = exports.createMemoString = exports.codeBodyString = exports.deserializeLPString = exports.serializeLPString = exports.deserializePrincipal = exports.serializePrincipal = exports.deserializeAddress = exports.serializeAddress = exports.addressFromPublicKeys = exports.addressFromHashMode = exports.createEmptyAddress = exports.deserializeStacksMessage = exports.serializeStacksMessage = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const utils_1 = require("./utils");
const postcondition_types_1 = require("./postcondition-types");
const payload_1 = require("./payload");
const errors_1 = require("./errors");
const signature_1 = require("./signature");
const common_2 = require("./common");
const clarity_1 = require("./clarity");
function serializeStacksMessage(message) {
    switch (message.type) {
        case constants_1.StacksMessageType.Address:
            return serializeAddress(message);
        case constants_1.StacksMessageType.Principal:
            return serializePrincipal(message);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return serializeLPString(message);
        case constants_1.StacksMessageType.MemoString:
            return serializeMemoString(message);
        case constants_1.StacksMessageType.AssetInfo:
            return serializeAssetInfo(message);
        case constants_1.StacksMessageType.PostCondition:
            return serializePostCondition(message);
        case constants_1.StacksMessageType.PublicKey:
            return (0, keys_1.serializePublicKey)(message);
        case constants_1.StacksMessageType.LengthPrefixedList:
            return serializeLPList(message);
        case constants_1.StacksMessageType.Payload:
            return (0, payload_1.serializePayload)(message);
        case constants_1.StacksMessageType.TransactionAuthField:
            return (0, signature_1.serializeTransactionAuthField)(message);
        case constants_1.StacksMessageType.MessageSignature:
            return (0, signature_1.serializeMessageSignature)(message);
    }
}
exports.serializeStacksMessage = serializeStacksMessage;
function deserializeStacksMessage(bytesReader, type, listType) {
    switch (type) {
        case constants_1.StacksMessageType.Address:
            return deserializeAddress(bytesReader);
        case constants_1.StacksMessageType.Principal:
            return deserializePrincipal(bytesReader);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return deserializeLPString(bytesReader);
        case constants_1.StacksMessageType.MemoString:
            return deserializeMemoString(bytesReader);
        case constants_1.StacksMessageType.AssetInfo:
            return deserializeAssetInfo(bytesReader);
        case constants_1.StacksMessageType.PostCondition:
            return deserializePostCondition(bytesReader);
        case constants_1.StacksMessageType.PublicKey:
            return (0, keys_1.deserializePublicKey)(bytesReader);
        case constants_1.StacksMessageType.Payload:
            return (0, payload_1.deserializePayload)(bytesReader);
        case constants_1.StacksMessageType.LengthPrefixedList:
            if (!listType) {
                throw new errors_1.DeserializationError('No List Type specified');
            }
            return deserializeLPList(bytesReader, listType);
        case constants_1.StacksMessageType.MessageSignature:
            return (0, signature_1.deserializeMessageSignature)(bytesReader);
        default:
            throw new Error('Could not recognize StacksMessageType');
    }
}
exports.deserializeStacksMessage = deserializeStacksMessage;
function createEmptyAddress() {
    return {
        type: constants_1.StacksMessageType.Address,
        version: constants_1.AddressVersion.MainnetSingleSig,
        hash160: '0'.repeat(40),
    };
}
exports.createEmptyAddress = createEmptyAddress;
function addressFromHashMode(hashMode, txVersion, data) {
    const version = (0, common_2.addressHashModeToVersion)(hashMode, txVersion);
    return (0, common_2.addressFromVersionHash)(version, data);
}
exports.addressFromHashMode = addressFromHashMode;
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
        throw Error('Invalid number of public keys');
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        if (publicKeys.length !== 1 || numSigs !== 1) {
            throw Error('Invalid number of public keys or signatures');
        }
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2WPKH || hashMode === constants_1.AddressHashMode.SerializeP2WSH) {
        for (let i = 0; i < publicKeys.length; i++) {
            if (!(0, keys_1.isCompressed)(publicKeys[i])) {
                throw Error('Public keys must be compressed for segwit');
            }
        }
    }
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2PKH)(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2WPKH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2WPKH)(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2SH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2SH)(numSigs, publicKeys.map(keys_1.serializePublicKey)));
        case constants_1.AddressHashMode.SerializeP2WSH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2WSH)(numSigs, publicKeys.map(keys_1.serializePublicKey)));
    }
}
exports.addressFromPublicKeys = addressFromPublicKeys;
function serializeAddress(address) {
    const bytesArray = [];
    bytesArray.push((0, common_1.hexToBytes)((0, common_1.intToHex)(address.version, 1)));
    bytesArray.push((0, common_1.hexToBytes)(address.hash160));
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeAddress = serializeAddress;
function deserializeAddress(bytesReader) {
    const version = (0, common_1.hexToInt)((0, common_1.bytesToHex)(bytesReader.readBytes(1)));
    const data = (0, common_1.bytesToHex)(bytesReader.readBytes(20));
    return { type: constants_1.StacksMessageType.Address, version, hash160: data };
}
exports.deserializeAddress = deserializeAddress;
function serializePrincipal(principal) {
    const bytesArray = [];
    bytesArray.push(principal.prefix);
    bytesArray.push(serializeAddress(principal.address));
    if (principal.prefix === constants_1.PostConditionPrincipalID.Contract) {
        bytesArray.push(serializeLPString(principal.contractName));
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializePrincipal = serializePrincipal;
function deserializePrincipal(bytesReader) {
    const prefix = bytesReader.readUInt8Enum(constants_1.PostConditionPrincipalID, n => {
        throw new errors_1.DeserializationError(`Unexpected Principal payload type: ${n}`);
    });
    const address = deserializeAddress(bytesReader);
    if (prefix === constants_1.PostConditionPrincipalID.Standard) {
        return { type: constants_1.StacksMessageType.Principal, prefix, address };
    }
    const contractName = deserializeLPString(bytesReader);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix,
        address,
        contractName,
    };
}
exports.deserializePrincipal = deserializePrincipal;
function serializeLPString(lps) {
    const bytesArray = [];
    const contentBytes = (0, common_1.utf8ToBytes)(lps.content);
    const length = contentBytes.byteLength;
    bytesArray.push((0, common_1.hexToBytes)((0, common_1.intToHex)(length, lps.lengthPrefixBytes)));
    bytesArray.push(contentBytes);
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeLPString = serializeLPString;
function deserializeLPString(bytesReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    const length = (0, common_1.hexToInt)((0, common_1.bytesToHex)(bytesReader.readBytes(prefixBytes)));
    const content = (0, common_1.bytesToUtf8)(bytesReader.readBytes(length));
    return (0, postcondition_types_1.createLPString)(content, prefixBytes, maxLength ?? 128);
}
exports.deserializeLPString = deserializeLPString;
function codeBodyString(content) {
    return (0, postcondition_types_1.createLPString)(content, 4, 100000);
}
exports.codeBodyString = codeBodyString;
function createMemoString(content) {
    if (content && (0, utils_1.exceedsMaxLengthBytes)(content, constants_1.MEMO_MAX_LENGTH_BYTES)) {
        throw new Error(`Memo exceeds maximum length of ${constants_1.MEMO_MAX_LENGTH_BYTES} bytes`);
    }
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.createMemoString = createMemoString;
function serializeMemoString(memoString) {
    const bytesArray = [];
    const contentBytes = (0, common_1.utf8ToBytes)(memoString.content);
    const paddedContent = (0, utils_1.rightPadHexToLength)((0, common_1.bytesToHex)(contentBytes), constants_1.MEMO_MAX_LENGTH_BYTES * 2);
    bytesArray.push((0, common_1.hexToBytes)(paddedContent));
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeMemoString = serializeMemoString;
function deserializeMemoString(bytesReader) {
    const content = (0, common_1.bytesToUtf8)(bytesReader.readBytes(constants_1.MEMO_MAX_LENGTH_BYTES));
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.deserializeMemoString = deserializeMemoString;
function serializeAssetInfo(info) {
    const bytesArray = [];
    bytesArray.push(serializeAddress(info.address));
    bytesArray.push(serializeLPString(info.contractName));
    bytesArray.push(serializeLPString(info.assetName));
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeAssetInfo = serializeAssetInfo;
function deserializeAssetInfo(bytesReader) {
    return {
        type: constants_1.StacksMessageType.AssetInfo,
        address: deserializeAddress(bytesReader),
        contractName: deserializeLPString(bytesReader),
        assetName: deserializeLPString(bytesReader),
    };
}
exports.deserializeAssetInfo = deserializeAssetInfo;
function createLPList(values, lengthPrefixBytes) {
    return {
        type: constants_1.StacksMessageType.LengthPrefixedList,
        lengthPrefixBytes: lengthPrefixBytes || 4,
        values,
    };
}
exports.createLPList = createLPList;
function serializeLPList(lpList) {
    const list = lpList.values;
    const bytesArray = [];
    bytesArray.push((0, common_1.hexToBytes)((0, common_1.intToHex)(list.length, lpList.lengthPrefixBytes)));
    for (const l of list) {
        bytesArray.push(serializeStacksMessage(l));
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeLPList = serializeLPList;
function deserializeLPList(bytesReader, type, lengthPrefixBytes) {
    const length = (0, common_1.hexToInt)((0, common_1.bytesToHex)(bytesReader.readBytes(lengthPrefixBytes || 4)));
    const l = [];
    for (let index = 0; index < length; index++) {
        switch (type) {
            case constants_1.StacksMessageType.Address:
                l.push(deserializeAddress(bytesReader));
                break;
            case constants_1.StacksMessageType.LengthPrefixedString:
                l.push(deserializeLPString(bytesReader));
                break;
            case constants_1.StacksMessageType.MemoString:
                l.push(deserializeMemoString(bytesReader));
                break;
            case constants_1.StacksMessageType.AssetInfo:
                l.push(deserializeAssetInfo(bytesReader));
                break;
            case constants_1.StacksMessageType.PostCondition:
                l.push(deserializePostCondition(bytesReader));
                break;
            case constants_1.StacksMessageType.PublicKey:
                l.push((0, keys_1.deserializePublicKey)(bytesReader));
                break;
            case constants_1.StacksMessageType.TransactionAuthField:
                l.push((0, signature_1.deserializeTransactionAuthField)(bytesReader));
                break;
        }
    }
    return createLPList(l, lengthPrefixBytes);
}
exports.deserializeLPList = deserializeLPList;
function serializePostCondition(postCondition) {
    const bytesArray = [];
    bytesArray.push(postCondition.conditionType);
    bytesArray.push(serializePrincipal(postCondition.principal));
    if (postCondition.conditionType === constants_1.PostConditionType.Fungible ||
        postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bytesArray.push(serializeAssetInfo(postCondition.assetInfo));
    }
    if (postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bytesArray.push((0, clarity_1.serializeCV)(postCondition.assetName));
    }
    bytesArray.push(postCondition.conditionCode);
    if (postCondition.conditionType === constants_1.PostConditionType.STX ||
        postCondition.conditionType === constants_1.PostConditionType.Fungible) {
        if (postCondition.amount > BigInt('0xffffffffffffffff'))
            throw new errors_1.SerializationError('The post-condition amount may not be larger than 8 bytes');
        bytesArray.push((0, common_1.intToBytes)(postCondition.amount, false, 8));
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializePostCondition = serializePostCondition;
function deserializePostCondition(bytesReader) {
    const postConditionType = bytesReader.readUInt8Enum(constants_1.PostConditionType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as PostConditionType`);
    });
    const principal = deserializePrincipal(bytesReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case constants_1.PostConditionType.STX:
            conditionCode = bytesReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt(`0x${(0, common_1.bytesToHex)(bytesReader.readBytes(8))}`);
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case constants_1.PostConditionType.Fungible:
            assetInfo = deserializeAssetInfo(bytesReader);
            conditionCode = bytesReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt(`0x${(0, common_1.bytesToHex)(bytesReader.readBytes(8))}`);
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case constants_1.PostConditionType.NonFungible:
            assetInfo = deserializeAssetInfo(bytesReader);
            const assetName = (0, clarity_1.deserializeCV)(bytesReader);
            conditionCode = bytesReader.readUInt8Enum(constants_1.NonFungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}
exports.deserializePostCondition = deserializePostCondition;
//# sourceMappingURL=types.js.map