"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateTransactionFeeWithFallback = exports.estimateTransactionByteLength = exports.sponsorTransaction = exports.getContractMapEntry = exports.callReadOnlyFunction = exports.makeContractNonFungiblePostCondition = exports.makeStandardNonFungiblePostCondition = exports.makeContractFungiblePostCondition = exports.makeStandardFungiblePostCondition = exports.makeContractSTXPostCondition = exports.makeStandardSTXPostCondition = exports.makeContractCall = exports.makeUnsignedContractCall = exports.estimateContractFunctionCall = exports.makeUnsignedContractDeploy = exports.makeContractDeploy = exports.estimateContractDeploy = exports.makeSTXTokenTransfer = exports.makeUnsignedSTXTokenTransfer = exports.getAbi = exports.broadcastRawTransaction = exports.broadcastTransaction = exports.estimateTransaction = exports.estimateTransferUnsafe = exports.estimateTransfer = exports.getNonce = void 0;
const common_1 = require("@stacks/common");
const network_1 = require("@stacks/network");
const c32check_1 = require("c32check");
const authorization_1 = require("./authorization");
const clarity_1 = require("./clarity");
const constants_1 = require("./constants");
const contract_abi_1 = require("./contract-abi");
const errors_1 = require("./errors");
const keys_1 = require("./keys");
const payload_1 = require("./payload");
const postcondition_1 = require("./postcondition");
const postcondition_types_1 = require("./postcondition-types");
const signer_1 = require("./signer");
const transaction_1 = require("./transaction");
const types_1 = require("./types");
const utils_1 = require("./utils");
async function getNonce(address, network) {
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? new network_1.StacksMainnet());
    const url = derivedNetwork.getAccountApiUrl(address);
    const response = await derivedNetwork.fetchFn(url);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseText = await response.text();
    const result = JSON.parse(responseText);
    return BigInt(result.nonce);
}
exports.getNonce = getNonce;
async function estimateTransfer(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.TokenTransfer) {
        throw new Error(`Transaction fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.TokenTransfer]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    return estimateTransferUnsafe(transaction, network);
}
exports.estimateTransfer = estimateTransfer;
async function estimateTransferUnsafe(transaction, network) {
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = BigInt(transaction.serialize().byteLength);
    const feeRate = BigInt(feeRateResult);
    return feeRate * txBytes;
}
exports.estimateTransferUnsafe = estimateTransferUnsafe;
async function estimateTransaction(transactionPayload, estimatedLen, network) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            transaction_payload: (0, common_1.bytesToHex)((0, payload_1.serializePayload)(transactionPayload)),
            ...(estimatedLen ? { estimated_len: estimatedLen } : {}),
        }),
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? new network_1.StacksMainnet());
    const url = derivedNetwork.getTransactionFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const body = await response.text().then(str => {
            try {
                return JSON.parse(str);
            }
            catch (error) {
                return str;
            }
        });
        if (body?.reason === 'NoEstimateAvailable' ||
            (typeof body === 'string' && body.includes('NoEstimateAvailable'))) {
            throw new errors_1.NoEstimateAvailableError(body?.reason_data?.message ?? '');
        }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${body}"`);
    }
    const data = await response.json();
    return data.estimations;
}
exports.estimateTransaction = estimateTransaction;
async function broadcastTransaction(transaction, network, attachment) {
    const rawTx = transaction.serialize();
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getBroadcastApiUrl();
    return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);
}
exports.broadcastTransaction = broadcastTransaction;
async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = (0, network_1.createFetchFn)()) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },
        body: attachment
            ? JSON.stringify({
                tx: (0, common_1.bytesToHex)(rawTx),
                attachment: (0, common_1.bytesToHex)(attachment),
            })
            : rawTx,
    };
    const response = await fetchFn(url, options);
    if (!response.ok) {
        try {
            return (await response.json());
        }
        catch (e) {
            throw Error(`Failed to broadcast transaction: ${e.message}`);
        }
    }
    const text = await response.text();
    const txid = text.replace(/["]+/g, '');
    if (!(0, utils_1.validateTxId)(txid))
        throw new Error(text);
    return { txid };
}
exports.broadcastRawTransaction = broadcastRawTransaction;
async function getAbi(address, contractName, network) {
    const options = {
        method: 'GET',
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network);
    const url = derivedNetwork.getAbiApiUrl(address, contractName);
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return JSON.parse(await response.text());
}
exports.getAbi = getAbi;
function deriveNetwork(transaction) {
    switch (transaction.version) {
        case constants_1.TransactionVersion.Mainnet:
            return new network_1.StacksMainnet();
        case constants_1.TransactionVersion.Testnet:
            return new network_1.StacksTestnet();
    }
}
async function makeUnsignedSTXTokenTransfer(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        memo: '',
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createTokenTransferPayload)(options.recipient, options.amount, options.memo);
    let authorization = null;
    let spendingCondition = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, undefined, undefined, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedSTXTokenTransfer = makeUnsignedSTXTokenTransfer;
async function makeSTXTokenTransfer(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedSTXTokenTransfer(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== (0, common_1.bytesToHex)(pubKey.data));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBytes)((0, common_1.hexToBytes)(key)));
        }
        return transaction;
    }
}
exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
async function estimateContractDeploy(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.SmartContract &&
        transaction.payload.payloadType !== constants_1.PayloadType.VersionedSmartContract) {
        throw new Error(`Contract deploy fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.SmartContract]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = (0, common_1.intToBigInt)(transaction.serialize().byteLength, false);
    const feeRate = (0, common_1.intToBigInt)(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractDeploy = estimateContractDeploy;
async function makeContractDeploy(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractDeploy({ publicKey, ...options });
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractDeploy(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== (0, common_1.bytesToHex)(pubKey.data));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBytes)((0, common_1.hexToBytes)(key)));
        }
        return transaction;
    }
}
exports.makeContractDeploy = makeContractDeploy;
async function makeUnsignedContractDeploy(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
        clarityVersion: constants_1.ClarityVersion.Clarity2,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createSmartContractPayload)(options.contractName, options.codeBody, options.clarityVersion);
    let authorization = null;
    let spendingCondition = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractDeploy = makeUnsignedContractDeploy;
async function estimateContractFunctionCall(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.ContractCall) {
        throw new Error(`Contract call fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.ContractCall]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = (0, common_1.intToBigInt)(transaction.serialize().byteLength, false);
    const feeRate = (0, common_1.intToBigInt)(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractFunctionCall = estimateContractFunctionCall;
async function makeUnsignedContractCall(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createContractCallPayload)(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
    if (options?.validateWithAbi) {
        let abi;
        if (typeof options.validateWithAbi === 'boolean') {
            if (options?.network) {
                abi = await getAbi(options.contractAddress, options.contractName, options.network);
            }
            else {
                throw new Error('Network option must be provided in order to validate with ABI');
            }
        }
        else {
            abi = options.validateWithAbi;
        }
        (0, contract_abi_1.validateContractCall)(payload, abi);
    }
    let spendingCondition = null;
    let authorization = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractCall = makeUnsignedContractCall;
async function makeContractCall(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractCall({ publicKey, ...options });
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractCall(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== (0, common_1.bytesToHex)(pubKey.data));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBytes)((0, common_1.hexToBytes)(key)));
        }
        return transaction;
    }
}
exports.makeContractCall = makeContractCall;
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, assetInfo, assetId);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, assetInfo, assetId);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
async function callReadOnlyFunction(readOnlyFunctionOptions) {
    const defaultOptions = {
        network: new network_1.StacksMainnet(),
    };
    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
    const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
    const args = functionArgs.map(arg => (0, utils_1.cvToHex)(arg));
    const body = JSON.stringify({
        sender: senderAddress,
        arguments: args,
    });
    const response = await network.fetchFn(url, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return response.json().then(responseJson => (0, utils_1.parseReadOnlyResponse)(responseJson));
}
exports.callReadOnlyFunction = callReadOnlyFunction;
async function getContractMapEntry(getContractMapEntryOptions) {
    const defaultOptions = {
        network: new network_1.StacksMainnet(),
    };
    const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(defaultOptions, getContractMapEntryOptions);
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network);
    const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);
    const serializedKeyBytes = (0, clarity_1.serializeCV)(mapKey);
    const serializedKeyHex = '0x' + (0, common_1.bytesToHex)(serializedKeyBytes);
    const fetchOptions = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
        },
        body: JSON.stringify(serializedKeyHex),
    };
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error fetching map entry for map "${mapName}" in contract "${contractName}" at address ${contractAddress}, using map key "${serializedKeyHex}". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseBody = await response.text();
    const responseJson = JSON.parse(responseBody);
    if (!responseJson.data) {
        throw new Error(`Error fetching map entry for map "${mapName}" in contract "${contractName}" at address ${contractAddress}, using map key "${serializedKeyHex}". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: "${responseBody}"`);
    }
    let deserializedCv;
    try {
        deserializedCv = (0, clarity_1.deserializeCV)(responseJson.data);
    }
    catch (error) {
        throw new Error(`Error deserializing Clarity value "${responseJson.data}": ${error}`);
    }
    return deserializedCv;
}
exports.getContractMapEntry = getContractMapEntry;
async function sponsorTransaction(sponsorOptions) {
    const defaultOptions = {
        fee: 0,
        sponsorNonce: 0,
        sponsorAddressHashmode: constants_1.AddressHashMode.SerializeP2PKH,
        network: sponsorOptions.transaction.version === constants_1.TransactionVersion.Mainnet
            ? new network_1.StacksMainnet()
            : new network_1.StacksTestnet(),
    };
    const options = Object.assign(defaultOptions, sponsorOptions);
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const sponsorPubKey = (0, keys_1.pubKeyfromPrivKey)(options.sponsorPrivateKey);
    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {
        let txFee = 0;
        switch (options.transaction.payload.payloadType) {
            case constants_1.PayloadType.TokenTransfer:
            case constants_1.PayloadType.SmartContract:
            case constants_1.PayloadType.VersionedSmartContract:
            case constants_1.PayloadType.ContractCall:
                const estimatedLen = estimateTransactionByteLength(options.transaction);
                try {
                    txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]
                        .fee;
                }
                catch (e) {
                    throw e;
                }
                break;
            default:
                throw new Error(`Sponsored transactions not supported for transaction type ${constants_1.PayloadType[options.transaction.payload.payloadType]}`);
        }
        options.transaction.setFee(txFee);
        options.fee = txFee;
    }
    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, keys_1.publicKeyToAddress)(addressVersion, sponsorPubKey);
        const sponsorNonce = await getNonce(senderAddress, network);
        options.sponsorNonce = sponsorNonce;
    }
    const sponsorSpendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(options.sponsorAddressHashmode, (0, keys_1.publicKeyToString)(sponsorPubKey), options.sponsorNonce, options.fee);
    options.transaction.setSponsor(sponsorSpendingCondition);
    const privKey = (0, keys_1.createStacksPrivateKey)(options.sponsorPrivateKey);
    const signer = signer_1.TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
    signer.signSponsor(privKey);
    return signer.transaction;
}
exports.sponsorTransaction = sponsorTransaction;
function estimateTransactionByteLength(transaction) {
    const hashMode = transaction.auth.spendingCondition.hashMode;
    const multiSigHashModes = [constants_1.AddressHashMode.SerializeP2SH, constants_1.AddressHashMode.SerializeP2WSH];
    if (multiSigHashModes.includes(hashMode)) {
        const multiSigSpendingCondition = transaction.auth
            .spendingCondition;
        const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === constants_1.StacksMessageType.MessageSignature).length;
        const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) *
            (constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);
        return transaction.serialize().byteLength + totalSignatureLength;
    }
    else {
        return transaction.serialize().byteLength;
    }
}
exports.estimateTransactionByteLength = estimateTransactionByteLength;
async function estimateTransactionFeeWithFallback(transaction, network) {
    try {
        const estimatedLen = estimateTransactionByteLength(transaction);
        return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;
    }
    catch (error) {
        if (error instanceof errors_1.NoEstimateAvailableError) {
            return await estimateTransferUnsafe(transaction, network);
        }
        throw error;
    }
}
exports.estimateTransactionFeeWithFallback = estimateTransactionFeeWithFallback;
//# sourceMappingURL=builders.js.map