import { IntegerType } from '@stacks/common';
import { StacksNetwork, StacksNetworkName, FetchFn } from '@stacks/network';
import { ClarityValue, NoneCV, PrincipalCV } from './clarity';
import { AddressHashMode, AnchorMode, FungibleConditionCode, NonFungibleConditionCode, PostConditionMode, TxRejectedReason, ClarityVersion, AnchorModeName } from './constants';
import { ClarityAbi } from './contract-abi';
import { Payload } from './payload';
import { AssetInfo, FungiblePostCondition, NonFungiblePostCondition, PostCondition, STXPostCondition } from './postcondition-types';
import { StacksTransaction } from './transaction';
export declare function getNonce(address: string, network?: StacksNetworkName | StacksNetwork): Promise<bigint>;
export declare function estimateTransfer(transaction: StacksTransaction, network?: StacksNetworkName | StacksNetwork): Promise<bigint>;
interface FeeEstimation {
    fee: number;
    fee_rate: number;
}
export declare function estimateTransaction(transactionPayload: Payload, estimatedLen?: number, network?: StacksNetworkName | StacksNetwork): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]>;
export type SerializationRejection = {
    error: string;
    reason: TxRejectedReason.Serialization;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type DeserializationRejection = {
    error: string;
    reason: TxRejectedReason.Deserialization;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type SignatureValidationRejection = {
    error: string;
    reason: TxRejectedReason.SignatureValidation;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type BadNonceRejection = {
    error: string;
    reason: TxRejectedReason.BadNonce;
    reason_data: {
        expected: number;
        actual: number;
        is_origin: boolean;
        principal: boolean;
    };
    txid: string;
};
export type FeeTooLowRejection = {
    error: string;
    reason: TxRejectedReason.FeeTooLow;
    reason_data: {
        expected: number;
        actual: number;
    };
    txid: string;
};
export type NotEnoughFundsRejection = {
    error: string;
    reason: TxRejectedReason.NotEnoughFunds;
    reason_data: {
        expected: string;
        actual: string;
    };
    txid: string;
};
export type NoSuchContractRejection = {
    error: string;
    reason: TxRejectedReason.NoSuchContract;
    reason_data?: undefined;
    txid: string;
};
export type NoSuchPublicFunctionRejection = {
    error: string;
    reason: TxRejectedReason.NoSuchPublicFunction;
    reason_data?: undefined;
    txid: string;
};
export type BadFunctionArgumentRejection = {
    error: string;
    reason: TxRejectedReason.BadFunctionArgument;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type ContractAlreadyExistsRejection = {
    error: string;
    reason: TxRejectedReason.ContractAlreadyExists;
    reason_data: {
        contract_identifier: string;
    };
    txid: string;
};
export type PoisonMicroblocksDoNotConflictRejection = {
    error: string;
    reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;
    reason_data?: undefined;
    txid: string;
};
export type PoisonMicroblockHasUnknownPubKeyHashRejection = {
    error: string;
    reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;
    reason_data?: undefined;
    txid: string;
};
export type PoisonMicroblockIsInvalidRejection = {
    error: string;
    reason: TxRejectedReason.PoisonMicroblockIsInvalid;
    reason_data?: undefined;
    txid: string;
};
export type BadAddressVersionByteRejection = {
    error: string;
    reason: TxRejectedReason.BadAddressVersionByte;
    reason_data?: undefined;
    txid: string;
};
export type NoCoinbaseViaMempoolRejection = {
    error: string;
    reason: TxRejectedReason.NoCoinbaseViaMempool;
    reason_data?: undefined;
    txid: string;
};
export type ServerFailureNoSuchChainTipRejection = {
    error: string;
    reason: TxRejectedReason.ServerFailureNoSuchChainTip;
    reason_data?: undefined;
    txid: string;
};
export type TooMuchChainingRejection = {
    error: string;
    reason: TxRejectedReason.TooMuchChaining;
    reason_data: {
        actual: number;
        expected: number;
        is_origin: boolean;
        message: string;
        principal: string;
    };
    txid: string;
};
export type ConflictingNonceInMempoolRejection = {
    error: string;
    reason: TxRejectedReason.ConflictingNonceInMempool;
    reason_data?: undefined;
    txid: string;
};
export type BadTransactionVersionRejection = {
    error: string;
    reason: TxRejectedReason.BadTransactionVersion;
    reason_data?: undefined;
    txid: string;
};
export type TransferRecipientCannotEqualSenderRejection = {
    error: string;
    reason: TxRejectedReason.TransferRecipientCannotEqualSender;
    reason_data: {
        recipient: string;
    };
    txid: string;
};
export type TransferAmountMustBePositiveRejection = {
    error: string;
    reason: TxRejectedReason.TransferAmountMustBePositive;
    reason_data?: undefined;
    txid: string;
};
export type ServerFailureDatabaseRejection = {
    error: string;
    reason: TxRejectedReason.ServerFailureDatabase;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type EstimatorErrorRejection = {
    error: string;
    reason: TxRejectedReason.EstimatorError;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type TemporarilyBlacklistedRejection = {
    error: string;
    reason: TxRejectedReason.TemporarilyBlacklisted;
    reason_data?: undefined;
    txid: string;
};
export type ServerFailureOtherRejection = {
    error: string;
    reason: TxRejectedReason.ServerFailureOther;
    reason_data: {
        message: string;
    };
    txid: string;
};
export type TxBroadcastResultOk = {
    txid: string;
    error?: undefined;
    reason?: undefined;
    reason_data?: undefined;
};
export type TxBroadcastResultRejected = SerializationRejection | DeserializationRejection | SignatureValidationRejection | BadNonceRejection | FeeTooLowRejection | NotEnoughFundsRejection | NoSuchContractRejection | NoSuchPublicFunctionRejection | BadFunctionArgumentRejection | ContractAlreadyExistsRejection | PoisonMicroblocksDoNotConflictRejection | PoisonMicroblockHasUnknownPubKeyHashRejection | PoisonMicroblockIsInvalidRejection | BadAddressVersionByteRejection | NoCoinbaseViaMempoolRejection | ServerFailureNoSuchChainTipRejection | TooMuchChainingRejection | ConflictingNonceInMempoolRejection | BadTransactionVersionRejection | TransferRecipientCannotEqualSenderRejection | TransferAmountMustBePositiveRejection | ServerFailureDatabaseRejection | EstimatorErrorRejection | TemporarilyBlacklistedRejection | ServerFailureOtherRejection;
export type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;
export declare function broadcastTransaction(transaction: StacksTransaction, network?: StacksNetworkName | StacksNetwork, attachment?: Uint8Array): Promise<TxBroadcastResult>;
export declare function broadcastRawTransaction(rawTx: Uint8Array, url: string, attachment?: Uint8Array, fetchFn?: FetchFn): Promise<TxBroadcastResult>;
export declare function getAbi(address: string, contractName: string, network: StacksNetworkName | StacksNetwork): Promise<ClarityAbi>;
export interface MultiSigOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys?: string[];
}
export interface TokenTransferOptions {
    recipient: string | PrincipalCV;
    amount: IntegerType;
    fee?: IntegerType;
    nonce?: IntegerType;
    network?: StacksNetworkName | StacksNetwork;
    anchorMode: AnchorModeName | AnchorMode;
    memo?: string;
    sponsored?: boolean;
}
export interface UnsignedTokenTransferOptions extends TokenTransferOptions {
    publicKey: string;
}
export interface SignedTokenTransferOptions extends TokenTransferOptions {
    senderKey: string;
}
export interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
}
export interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
export declare function makeUnsignedSTXTokenTransfer(txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions): Promise<StacksTransaction>;
export declare function makeSTXTokenTransfer(txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions): Promise<StacksTransaction>;
export interface BaseContractDeployOptions {
    clarityVersion?: ClarityVersion;
    contractName: string;
    codeBody: string;
    fee?: IntegerType;
    nonce?: IntegerType;
    network?: StacksNetworkName | StacksNetwork;
    anchorMode: AnchorModeName | AnchorMode;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    sponsored?: boolean;
}
export interface UnsignedContractDeployOptions extends BaseContractDeployOptions {
    publicKey: string;
}
export interface SignedContractDeployOptions extends BaseContractDeployOptions {
    senderKey: string;
}
export interface ContractDeployOptions extends SignedContractDeployOptions {
}
export interface UnsignedMultiSigContractDeployOptions extends BaseContractDeployOptions {
    numSignatures: number;
    publicKeys: string[];
}
export interface SignedMultiSigContractDeployOptions extends BaseContractDeployOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
export declare function estimateContractDeploy(transaction: StacksTransaction, network?: StacksNetworkName | StacksNetwork): Promise<bigint>;
export declare function makeContractDeploy(txOptions: SignedContractDeployOptions | SignedMultiSigContractDeployOptions): Promise<StacksTransaction>;
export declare function makeUnsignedContractDeploy(txOptions: UnsignedContractDeployOptions | UnsignedMultiSigContractDeployOptions): Promise<StacksTransaction>;
export interface ContractCallOptions {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: ClarityValue[];
    fee?: IntegerType;
    feeEstimateApiUrl?: string;
    nonce?: IntegerType;
    network?: StacksNetworkName | StacksNetwork;
    anchorMode: AnchorModeName | AnchorMode;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    validateWithAbi?: boolean | ClarityAbi;
    sponsored?: boolean;
}
export interface UnsignedContractCallOptions extends ContractCallOptions {
    publicKey: string;
}
export interface SignedContractCallOptions extends ContractCallOptions {
    senderKey: string;
}
export interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {
    numSignatures: number;
    publicKeys: string[];
}
export interface SignedMultiSigContractCallOptions extends ContractCallOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
export declare function estimateContractFunctionCall(transaction: StacksTransaction, network?: StacksNetworkName | StacksNetwork): Promise<bigint>;
export declare function makeUnsignedContractCall(txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions): Promise<StacksTransaction>;
export declare function makeContractCall(txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions): Promise<StacksTransaction>;
export declare function makeStandardSTXPostCondition(address: string, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
export declare function makeContractSTXPostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
export declare function makeStandardFungiblePostCondition(address: string, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
export declare function makeContractFungiblePostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
export declare function makeStandardNonFungiblePostCondition(address: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetId: ClarityValue): NonFungiblePostCondition;
export declare function makeContractNonFungiblePostCondition(address: string, contractName: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetId: ClarityValue): NonFungiblePostCondition;
export interface ReadOnlyFunctionOptions {
    contractName: string;
    contractAddress: string;
    functionName: string;
    functionArgs: ClarityValue[];
    network?: StacksNetworkName | StacksNetwork;
    senderAddress: string;
}
export declare function callReadOnlyFunction(readOnlyFunctionOptions: ReadOnlyFunctionOptions): Promise<ClarityValue>;
export interface GetContractMapEntryOptions {
    contractAddress: string;
    contractName: string;
    mapName: string;
    mapKey: ClarityValue;
    network?: StacksNetworkName | StacksNetwork;
}
export declare function getContractMapEntry<T extends ClarityValue = ClarityValue>(getContractMapEntryOptions: GetContractMapEntryOptions): Promise<T | NoneCV>;
export interface SponsorOptionsOpts {
    transaction: StacksTransaction;
    sponsorPrivateKey: string;
    fee?: IntegerType;
    sponsorNonce?: IntegerType;
    sponsorAddressHashmode?: AddressHashMode;
    network?: StacksNetworkName | StacksNetwork;
}
export declare function sponsorTransaction(sponsorOptions: SponsorOptionsOpts): Promise<StacksTransaction>;
export declare function estimateTransactionByteLength(transaction: StacksTransaction): number;
export declare function estimateTransactionFeeWithFallback(transaction: StacksTransaction, network: StacksNetwork): Promise<bigint | number>;
export {};
