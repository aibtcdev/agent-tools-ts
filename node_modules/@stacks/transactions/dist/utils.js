"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTxId = exports.validateStacksAddress = exports.parseReadOnlyResponse = exports.hexToCV = exports.cvToHex = exports.isClarityName = exports.hashP2WSH = exports.hashP2SH = exports.hashP2WPKH = exports.hashP2PKH = exports.txidFromBytes = exports.txidFromData = exports.hash160 = exports.omit = exports.cloneDeep = exports.exceedsMaxLengthBytes = exports.rightPadHexToLength = exports.leftPadHexToLength = exports.leftPadHex = exports.randomBytes = exports.verifySignature = void 0;
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const c32check_1 = require("c32check");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const clarity_1 = require("./clarity");
var secp256k1_2 = require("@noble/secp256k1");
Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function () { return secp256k1_2.verify; } });
const randomBytes = (bytesLength) => secp256k1_1.utils.randomBytes(bytesLength);
exports.randomBytes = randomBytes;
const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
exports.leftPadHex = leftPadHex;
const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
exports.leftPadHexToLength = leftPadHexToLength;
const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
exports.rightPadHexToLength = rightPadHexToLength;
const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? (0, common_1.utf8ToBytes)(string).length > maxLengthBytes : false;
exports.exceedsMaxLengthBytes = exceedsMaxLengthBytes;
function cloneDeep(obj) {
    return (0, lodash_clonedeep_1.default)(obj);
}
exports.cloneDeep = cloneDeep;
function omit(obj, prop) {
    const clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
}
exports.omit = omit;
const hash160 = (input) => {
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(input));
};
exports.hash160 = hash160;
const txidFromData = (data) => {
    return (0, common_1.bytesToHex)((0, sha512_1.sha512_256)(data));
};
exports.txidFromData = txidFromData;
exports.txidFromBytes = exports.txidFromData;
const hashP2PKH = (input) => {
    return (0, common_1.bytesToHex)((0, exports.hash160)(input));
};
exports.hashP2PKH = hashP2PKH;
const hashP2WPKH = (input) => {
    const keyHash = (0, exports.hash160)(input);
    const redeemScript = (0, common_1.concatBytes)(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2WPKH = hashP2WPKH;
const hashP2SH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2SH multisig address can only contain up to 15 public keys');
    }
    const bytesArray = [];
    bytesArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        bytesArray.push(pubKey.length);
        bytesArray.push(pubKey);
    });
    bytesArray.push(80 + pubKeys.length);
    bytesArray.push(174);
    const redeemScript = (0, common_1.concatArray)(bytesArray);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2SH = hashP2SH;
const hashP2WSH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2WSH multisig address can only contain up to 15 public keys');
    }
    const scriptArray = [];
    scriptArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        scriptArray.push(pubKey.length);
        scriptArray.push(pubKey);
    });
    scriptArray.push(80 + pubKeys.length);
    scriptArray.push(174);
    const script = (0, common_1.concatArray)(scriptArray);
    const digest = (0, sha256_1.sha256)(script);
    const bytesArray = [];
    bytesArray.push(0);
    bytesArray.push(digest.length);
    bytesArray.push(digest);
    const redeemScript = (0, common_1.concatArray)(bytesArray);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2WSH = hashP2WSH;
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
exports.isClarityName = isClarityName;
function cvToHex(cv) {
    const serialized = (0, clarity_1.serializeCV)(cv);
    return `0x${(0, common_1.bytesToHex)(serialized)}`;
}
exports.cvToHex = cvToHex;
function hexToCV(hex) {
    return (0, clarity_1.deserializeCV)(hex);
}
exports.hexToCV = hexToCV;
const parseReadOnlyResponse = (response) => {
    if (response.okay)
        return hexToCV(response.result);
    throw new Error(response.cause);
};
exports.parseReadOnlyResponse = parseReadOnlyResponse;
const validateStacksAddress = (stacksAddress) => {
    try {
        (0, c32check_1.c32addressDecode)(stacksAddress);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.validateStacksAddress = validateStacksAddress;
const validateTxId = (txid) => {
    if (txid === 'success')
        return true;
    const value = (0, common_1.with0x)(txid).toLowerCase();
    if (value.length !== 66)
        return false;
    return (0, common_1.with0x)(BigInt(value).toString(16).padStart(64, '0')) === value;
};
exports.validateTxId = validateTxId;
//# sourceMappingURL=utils.js.map